
@startuml

set namespaceSeparator ::

interface nvimrpc::IoDevice {
	+virtual size_t send(string_view)
	+virtual size_t recv(string, timeout)
}

class nvimrpc::ReprocDevice {
	-reproc::process process;
	-std::mutex m;
	-std::string output;
	-std::future<std::error_code> drain_async;

	+int spawn(char **argv)
	+int kill()
}

class nvimrpc::StreamDecoder {
	-mpack_tree_t tree;
	-static size_t read_iodev(mpack_tree_t *ptree, char *buf, size_t count)

	+std::optional<mpack_node_t> poll()
}

class nvimrpc::StreamWorker {
	-std::mutex qm;
	-std::condition_variable cv;
	-std::queue<mpack_node_t> nodes;
	-std::vector<uint8_t> raw_data;
	-std::thread t;
	-IoDevice &dev; ' Used to read data
	-std::optional<mpack_node_t> try_parse(raw_data);

	+void wait_for_data() ' simulates `reproc::drain`
}

class nvimrpc::Api {
	-msgid = 0;
	-std::queue pending_notif;
	-IoDevice &dev; ' Used to send data in dispatch function
	-StreamWorker &worker;
	' Uses worker to wait for a mpack_node_t
	-auto poll(msgid, timeout);
	-dispatch(const std::string& func, Args... args)
	+int get_new_msgid() { return ++msgid; }
	' This function basically calls dispatch and then poll
	+auto generated_functions_from_api()
	' Todo
	+virtual auto generated_notifications_handles()
}

class nvimrpc::IMpackNotifUnPack {
	' -mpack_reader_t reader;
	' -T mpack_write();

	' TODO in this function check the msg type to ensure its a notification type
	+int set_data(string);
	+int get_method_name();
	+T get_params();
	' On destruction call
	'mpack_reader_destroy, see its help
}

class nvimrpc::IMpackResUnPack {
	-mpack_reader_t reader;
	-T mpack_write();

	' TODO in this function check the msg type to ensure its a response type
	+int set_data(string);
	+int get_msg_type();
	+int get_msgid();
	+int get_error();
	+auto get_result();
	' On destruction call
	'mpack_reader_destroy, see its help
}

class nvimrpc::IMpackReqPack {
	-char *data;
	-size_t data_size;

	+virtual void set_msgid(int);
	+virtual void set_funcname(string);
	+virtual void set_args(Args... args);
	+virtual string build();
}

' TODO Call MPACK_FREE(data) on destructor
class nvimrpc::MpackReqPack {
	-char *data;
	-size_t data_size;
	-mpack_writer_t writer;
	-void mpack_write();

	+virtual void set_msgid(int);
	+virtual void set_funcname(string);
	+virtual void set_args(Args... args);
	+virtual string build();
}

' Example controller
class nvimrpc::Client {
	-nvimrpc::IoDevice &device;
	-StreamWorker stream;
}

enum nvimrpc::MessageType: <int64_t> {
	REQUEST = 0,
	RESPONSE = 1,
	NOTIFICATION = 2
}

class nvimrpc::Types {
	using object = std::variant<
		bool,
		int64_t,
		double,
		std::string,
		std::vector<libnvc::object_wrapper>,
		std::unordered_map<std::string, libnvc::object_wrapper>
		>;
}
class MpackWriter {
}

nvimrpc::Client *-- nvimrpc::StreamDecoder
nvimrpc::Client *-left- nvimrpc::IoDevice
nvimrpc::IoDevice <|-- nvimrpc::ReprocDevice
nvimrpc::StreamDecoder -- nvimrpc::IoDevice : uses >

@enduml


@startuml

set namespaceSeparator ::

interface nvimrpc::IoDevice {
	+virtual size_t send(string_view)
	+virtual size_t recv(string, timeout)
}

class nvimrpc::ReprocDevice {
	-reproc::process process;
	-std::mutex m;
	-std::string output;
	-std::future<std::error_code> drain_async;

	+int spawn(char **argv)
	+int kill()
}

class nvimrpc::StreamDecoder {
	-mpack_tree_t tree;
	-static size_t read_iodev(mpack_tree_t *ptree, char *buf, size_t count)

	+std::optional<mpack_node_t> poll()
}

class nvimrpc::StreamWorker {
	-std::thread t;
	-StreamDecoder stream;
	-std::queue<mpack_node_t> root_q;

	+std::optional<std::queue<mpack_node_t>> get_messages();
}

class nvimrpc::Api {
	-dispatch(const std::string& func, Args... args)
	+auto generated_functions_from_api()
	+virtual auto generated_notifications_handles()
}

class nvimrpc::IDataSerializer {
	-char *data;
	-size_t data_size;

	+virtual void set_msgid(int);
	+virtual void set_funcname(string);
	+virtual void set_args(Args... args);
	+virtual string build();
}

class nvimrpc::DataSerializer {
	-char *data;
	-size_t data_size;
	-mpack_writer_t writer;
	-void mpack_write();

	+virtual void set_msgid(int);
	+virtual void set_funcname(string);
	+virtual void set_args(Args... args);
	+virtual string build();
}

' Example controller
class nvimrpc::Client {
	-nvimrpc::IoDevice &device;
	-StreamWorker stream;
}

enum nvimrpc::MessageType: <int64_t> {
	REQUEST = 0,
	RESPONSE = 1,
	NOTIFICATION = 2
}

class nvimrpc::Types {
	using object = std::variant<
		bool,
		int64_t,
		double,
		std::string,
		std::vector<libnvc::object_wrapper>,
		std::unordered_map<std::string, libnvc::object_wrapper>
		>;
}
class MpackWriter {
}

nvimrpc::Client *-- nvimrpc::StreamDecoder
nvimrpc::Client *-left- nvimrpc::IoDevice
nvimrpc::IoDevice <|-- nvimrpc::ReprocDevice
nvimrpc::StreamDecoder -- nvimrpc::IoDevice : uses >

@enduml
